/*
 * generated by Xtext
 */
package de.nittka.tooling.xarchive.validation

import de.nittka.tooling.xarchive.xarchive.Document
import org.eclipse.xtext.validation.Check
import de.nittka.tooling.xarchive.xarchive.CategoryType
import java.util.Set
import de.nittka.tooling.xarchive.xarchive.XarchivePackage
import de.nittka.tooling.xarchive.xarchive.DocumentFileName
import java.util.regex.Pattern

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class XarchiveValidator extends AbstractXarchiveValidator {

	val public static FILE_NAME="filename"

	@Check
	def checkDuplicateCategory(Document doc) {
		val Set<CategoryType> types=newHashSet()
		doc.categories.forEach[
			val t=it.type
			if (types.contains(t)){
				error("duplicate category", it, XarchivePackage.Literals.CATEGORY_REF__TYPE)
			}else{
				types.add(t)
			}
		]
	}

	@Check
	def checkFileName(DocumentFileName file) {
		val resourceName=file.eResource.URI.trimFileExtension.lastSegment
		if(file.fileName!=resourceName){
			error('''illegal file name: '«resourceName»' expected''', XarchivePackage.Literals.DOCUMENT_FILE_NAME__FILE_NAME, FILE_NAME, file.fileName, resourceName)
		}
	}

	val static Pattern datePattern=Pattern.compile("\\d{4}(-\\d{2}){0,2}")

	@Check
	def checkDateFormant(Document doc) {
		if(doc.date!==null){
			if(!datePattern.matcher(doc.date).matches){
				error("illegal date format (yyyy, yyyy-mm, or yyyy-mm-dd)", XarchivePackage.Literals.DOCUMENT__DATE)
			}
		}
	}
}
